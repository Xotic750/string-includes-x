{"version":3,"sources":["../src/string-includes-x.js"],"names":[],"mappings":"AAAA,OAAO,OAAP,MAAoB,WAApB;AACA,OAAO,QAAP,MAAqB,aAArB;AACA,OAAO,KAAP,MAAkB,aAAlB;AACA,OAAO,sBAAP,MAAmC,4BAAnC;AACA,OAAO,SAAP,MAAsB,cAAtB;AACA,OAAO,SAAP,MAAsB,oBAAtB;AAEA,IAAM,YAAY,GAAG,EAArB;AACA,IAAM,OAAO,GAAG,SAAS,CAAC,YAAY,CAAC,OAAd,CAAzB;IACiB,E,GAAM,Y,CAAhB,Q;AACP,IAAM,cAAc,GAAG,OAAO,EAAP,KAAc,UAAd,IAA4B,EAAnD;AACA,IAAM,kBAAkB,GAAG,cAAc,IAAI,SAAS,CAAC,cAAD,CAAtD;;AAEA,IAAM,KAAK,GAAG,SAAS,KAAT,GAAiB;AAC7B,SAAO,OAAO,CAAC,kBAAD,EAAqB,KAArB,EAA4B,GAA5B,CAAP,CAAwC,KAA/C;AACD,CAFD;;AAIA,IAAM,KAAK,GAAG,SAAS,KAAT,GAAiB;AAC7B,MAAM,GAAG,GAAG,OAAO,CAAC,kBAAD,EAAqB,KAArB,EAA4B,GAA5B,EAAiC,QAAjC,CAAnB;AAEA,SAAO,GAAG,CAAC,KAAJ,KAAc,KAAd,IAAuB,GAAG,CAAC,KAAJ,KAAc,KAA5C;AACD,CAJD;;AAMA,IAAM,KAAK,GAAG,SAAS,KAAT,GAAiB;AAC7B,MAAM,GAAG,GAAG,OAAO,CAAC,kBAAD,EAAqB,GAArB,EAA0B,GAA1B,CAAnB;AAEA,SAAO,GAAG,CAAC,KAAJ,KAAc,KAAd,IAAuB,GAAG,CAAC,KAAJ,KAAc,IAA5C;AACD,CAJD;;AAMA,IAAM,KAAK,GAAG,SAAS,KAAT,GAAiB;AAC7B,SAAO,OAAO,CAAC,kBAAD,EAAqB,IAArB,EAA2B,GAA3B,CAAP,CAAuC,KAA9C;AACD,CAFD;;AAIA,IAAM,SAAS,GAAG,SAAS,CAAC,kBAAD,CAAT,IAAiC,KAAK,EAAtC,IAA4C,KAAK,EAAjD,IAAuD,KAAK,EAA5D,IAAkE,KAAK,EAAzF;;AAEA,IAAM,WAAW,GAAG,SAAS,WAAT,CAAqB,YAArB,EAAmC;AACrD,MAAI,QAAQ,CAAC,YAAD,CAAZ,EAA4B;AAC1B,UAAM,IAAI,SAAJ,CAAc,qCAAd,CAAN;AACD;;AAED,SAAO,YAAP;AACD,CAND;;AAQA,IAAM,eAAe,GAAG,SAAS,QAAT,CAAkB,MAAlB,EAA0B,YAA1B,EAAwC;AAC9D;AACA,SAAO,kBAAkB,CAAC,sBAAsB,CAAC,MAAD,CAAvB,EAAiC,WAAW,CAAC,YAAD,CAA5C,EAA4D,SAAS,CAAC,CAAD,CAArE,CAAzB;AACD,CAHD;;AAKA,OAAO,IAAM,cAAc,GAAG,SAAS,QAAT,CAAkB,MAAlB,EAA0B,YAA1B,EAAwC;AACpE;;AACA;AACA,SAAO,OAAO,CAAC,KAAK,CAAC,sBAAsB,CAAC,MAAD,CAAvB,CAAN,EAAwC,KAAK,CAAC,WAAW,CAAC,YAAD,CAAZ,CAA7C,EAA0E,SAAS,CAAC,CAAD,CAAnF,CAAP,KAAmG,CAAC,CAA3G;AACD,CAJM;AAMP;;;;;;;;;;;;;;;AAcA,IAAM,SAAS,GAAG,SAAS,GAAG,eAAH,GAAqB,cAAhD;AAEA,eAAe,SAAf","file":"string-includes-x.esm.js","sourcesContent":["import attempt from 'attempt-x';\nimport isRegExp from 'is-regexp-x';\nimport toStr from 'to-string-x';\nimport requireObjectCoercible from 'require-object-coercible-x';\nimport toBoolean from 'to-boolean-x';\nimport methodize from 'simple-methodize-x';\n\nconst EMPTY_STRING = '';\nconst indexOf = methodize(EMPTY_STRING.indexOf);\nconst {includes: ni} = EMPTY_STRING;\nconst nativeIncludes = typeof ni === 'function' && ni;\nconst methodizedIncludes = nativeIncludes && methodize(nativeIncludes);\n\nconst test1 = function test1() {\n  return attempt(methodizedIncludes, '/a/', /a/).threw;\n};\n\nconst test2 = function test2() {\n  const res = attempt(methodizedIncludes, 'abc', 'a', Infinity);\n\n  return res.threw === false && res.value === false;\n};\n\nconst test3 = function test3() {\n  const res = attempt(methodizedIncludes, 123, '2');\n\n  return res.threw === false && res.value === true;\n};\n\nconst test4 = function test4() {\n  return attempt(methodizedIncludes, null, 'u').threw;\n};\n\nconst isWorking = toBoolean(methodizedIncludes) && test1() && test2() && test3() && test4();\n\nconst assertRegex = function assertRegex(searchString) {\n  if (isRegExp(searchString)) {\n    throw new TypeError('\"includes\" does not accept a RegExp');\n  }\n\n  return searchString;\n};\n\nconst patchedIncludes = function includes(string, searchString) {\n  /* eslint-disable-next-line prefer-rest-params */\n  return methodizedIncludes(requireObjectCoercible(string), assertRegex(searchString), arguments[2]);\n};\n\nexport const implementation = function includes(string, searchString) {\n  // Somehow this trick makes method 100% compat with the spec.\n  /* eslint-disable-next-line prefer-rest-params */\n  return indexOf(toStr(requireObjectCoercible(string)), toStr(assertRegex(searchString)), arguments[2]) !== -1;\n};\n\n/**\n * This method determines whether one string may be found within another string,\n * returning true or false as appropriate.\n *\n * @param {string} string - The target string.\n * @throws {TypeError} If target is null or undefined.\n * @param {string} searchString - A string to be searched for within the\n *  target string.\n * @throws {TypeError} If searchString is a RegExp.\n * @param {number} [position] -The position within the string at which to begin\n *  searching for searchString.(defaults to 0).\n * @returns {boolean} `true` if the given string is found anywhere within the\n *  search string; otherwise, `false` if not.\n */\nconst $includes = isWorking ? patchedIncludes : implementation;\n\nexport default $includes;\n"]}